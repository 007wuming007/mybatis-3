<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>MapperBuilderAssistant.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">mybatis</a> &gt; <a href="index.source.html" class="el_package">org.apache.ibatis.builder</a> &gt; <span class="el_source">MapperBuilderAssistant.java</span></div><h1>MapperBuilderAssistant.java</h1><pre class="source lang-java linenums">/**
 *    Copyright 2009-2015 the original author or authors.
 *
 *    Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */
package org.apache.ibatis.builder;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.Set;
import java.util.StringTokenizer;

import org.apache.ibatis.cache.Cache;
import org.apache.ibatis.cache.decorators.LruCache;
import org.apache.ibatis.cache.impl.PerpetualCache;
import org.apache.ibatis.executor.ErrorContext;
import org.apache.ibatis.executor.keygen.KeyGenerator;
import org.apache.ibatis.mapping.CacheBuilder;
import org.apache.ibatis.mapping.Discriminator;
import org.apache.ibatis.mapping.MappedStatement;
import org.apache.ibatis.mapping.ParameterMap;
import org.apache.ibatis.mapping.ParameterMapping;
import org.apache.ibatis.mapping.ParameterMode;
import org.apache.ibatis.mapping.ResultFlag;
import org.apache.ibatis.mapping.ResultMap;
import org.apache.ibatis.mapping.ResultMapping;
import org.apache.ibatis.mapping.ResultSetType;
import org.apache.ibatis.mapping.SqlCommandType;
import org.apache.ibatis.mapping.SqlSource;
import org.apache.ibatis.mapping.StatementType;
import org.apache.ibatis.reflection.MetaClass;
import org.apache.ibatis.scripting.LanguageDriver;
import org.apache.ibatis.session.Configuration;
import org.apache.ibatis.type.JdbcType;
import org.apache.ibatis.type.TypeHandler;

/**
 * @author Clinton Begin
 */
public class MapperBuilderAssistant extends BaseBuilder {

  private String currentNamespace;
  private String resource;
  private Cache currentCache;
  private boolean unresolvedCacheRef; // issue #676

  public MapperBuilderAssistant(Configuration configuration, String resource) {
<span class="fc" id="L63">    super(configuration);</span>
<span class="fc" id="L64">    ErrorContext.instance().resource(resource);</span>
<span class="fc" id="L65">    this.resource = resource;</span>
<span class="fc" id="L66">  }</span>

  public String getCurrentNamespace() {
<span class="fc" id="L69">    return currentNamespace;</span>
  }

  public void setCurrentNamespace(String currentNamespace) {
<span class="pc bpc" id="L73" title="1 of 2 branches missed.">    if (currentNamespace == null) {</span>
<span class="nc" id="L74">      throw new BuilderException(&quot;The mapper element requires a namespace attribute to be specified.&quot;);</span>
    }

<span class="fc bfc" id="L77" title="All 4 branches covered.">    if (this.currentNamespace != null &amp;&amp; !this.currentNamespace.equals(currentNamespace)) {</span>
<span class="fc" id="L78">      throw new BuilderException(&quot;Wrong namespace. Expected '&quot;</span>
          + this.currentNamespace + &quot;' but found '&quot; + currentNamespace + &quot;'.&quot;);
    }

<span class="fc" id="L82">    this.currentNamespace = currentNamespace;</span>
<span class="fc" id="L83">  }</span>

  public String applyCurrentNamespace(String base, boolean isReference) {
<span class="fc bfc" id="L86" title="All 2 branches covered.">    if (base == null) {</span>
<span class="fc" id="L87">      return null;</span>
    }
<span class="fc bfc" id="L89" title="All 2 branches covered.">    if (isReference) {</span>
      // is it qualified with any namespace yet?
<span class="fc bfc" id="L91" title="All 2 branches covered.">      if (base.contains(&quot;.&quot;)) {</span>
<span class="fc" id="L92">        return base;</span>
      }
    } else {
      // is it qualified with this namespace yet?
<span class="fc bfc" id="L96" title="All 2 branches covered.">      if (base.startsWith(currentNamespace + &quot;.&quot;)) {</span>
<span class="fc" id="L97">        return base;</span>
      }
<span class="fc bfc" id="L99" title="All 2 branches covered.">      if (base.contains(&quot;.&quot;)) {</span>
<span class="fc" id="L100">        throw new BuilderException(&quot;Dots are not allowed in element names, please remove it from &quot; + base);</span>
      }
    }
<span class="fc" id="L103">    return currentNamespace + &quot;.&quot; + base;</span>
  }

  public Cache useCacheRef(String namespace) {
<span class="pc bpc" id="L107" title="1 of 2 branches missed.">    if (namespace == null) {</span>
<span class="nc" id="L108">      throw new BuilderException(&quot;cache-ref element requires a namespace attribute.&quot;);</span>
    }
    try {
<span class="fc" id="L111">      unresolvedCacheRef = true;</span>
<span class="fc" id="L112">      Cache cache = configuration.getCache(namespace);</span>
<span class="pc bpc" id="L113" title="1 of 2 branches missed.">      if (cache == null) {</span>
<span class="nc" id="L114">        throw new IncompleteElementException(&quot;No cache for namespace '&quot; + namespace + &quot;' could be found.&quot;);</span>
      }
<span class="fc" id="L116">      currentCache = cache;</span>
<span class="fc" id="L117">      unresolvedCacheRef = false;</span>
<span class="fc" id="L118">      return cache;</span>
<span class="fc" id="L119">    } catch (IllegalArgumentException e) {</span>
<span class="fc" id="L120">      throw new IncompleteElementException(&quot;No cache for namespace '&quot; + namespace + &quot;' could be found.&quot;, e);</span>
    }
  }

  public Cache useNewCache(Class&lt;? extends Cache&gt; typeClass,
      Class&lt;? extends Cache&gt; evictionClass,
      Long flushInterval,
      Integer size,
      boolean readWrite,
      boolean blocking,
      Properties props) {
<span class="fc" id="L131">    typeClass = valueOrDefault(typeClass, PerpetualCache.class);</span>
<span class="fc" id="L132">    evictionClass = valueOrDefault(evictionClass, LruCache.class);</span>
<span class="fc" id="L133">    Cache cache = new CacheBuilder(currentNamespace)</span>
        .implementation(typeClass)
        .addDecorator(evictionClass)
        .clearInterval(flushInterval)
        .size(size)
        .readWrite(readWrite)
        .blocking(blocking)
        .properties(props)
        .build();
<span class="fc" id="L142">    configuration.addCache(cache);</span>
<span class="fc" id="L143">    currentCache = cache;</span>
<span class="fc" id="L144">    return cache;</span>
  }

  public ParameterMap addParameterMap(String id, Class&lt;?&gt; parameterClass, List&lt;ParameterMapping&gt; parameterMappings) {
<span class="fc" id="L148">    id = applyCurrentNamespace(id, false);</span>
<span class="fc" id="L149">    ParameterMap.Builder parameterMapBuilder = new ParameterMap.Builder(configuration, id, parameterClass, parameterMappings);</span>
<span class="fc" id="L150">    ParameterMap parameterMap = parameterMapBuilder.build();</span>
<span class="fc" id="L151">    configuration.addParameterMap(parameterMap);</span>
<span class="fc" id="L152">    return parameterMap;</span>
  }

  public ParameterMapping buildParameterMapping(
      Class&lt;?&gt; parameterType,
      String property,
      Class&lt;?&gt; javaType,
      JdbcType jdbcType,
      String resultMap,
      ParameterMode parameterMode,
      Class&lt;? extends TypeHandler&lt;?&gt;&gt; typeHandler,
      Integer numericScale) {
<span class="fc" id="L164">    resultMap = applyCurrentNamespace(resultMap, true);</span>

    // Class parameterType = parameterMapBuilder.type();
<span class="fc" id="L167">    Class&lt;?&gt; javaTypeClass = resolveParameterJavaType(parameterType, property, javaType, jdbcType);</span>
<span class="fc" id="L168">    TypeHandler&lt;?&gt; typeHandlerInstance = resolveTypeHandler(javaTypeClass, typeHandler);</span>

<span class="fc" id="L170">    ParameterMapping.Builder builder = new ParameterMapping.Builder(configuration, property, javaTypeClass);</span>
<span class="fc" id="L171">    builder.jdbcType(jdbcType);</span>
<span class="fc" id="L172">    builder.resultMapId(resultMap);</span>
<span class="fc" id="L173">    builder.mode(parameterMode);</span>
<span class="fc" id="L174">    builder.numericScale(numericScale);</span>
<span class="fc" id="L175">    builder.typeHandler(typeHandlerInstance);</span>
<span class="fc" id="L176">    return builder.build();</span>
  }

  public ResultMap addResultMap(
      String id,
      Class&lt;?&gt; type,
      String extend,
      Discriminator discriminator,
      List&lt;ResultMapping&gt; resultMappings,
      Boolean autoMapping) {
<span class="fc" id="L186">    id = applyCurrentNamespace(id, false);</span>
<span class="fc" id="L187">    extend = applyCurrentNamespace(extend, true);</span>

<span class="fc" id="L189">    ResultMap.Builder resultMapBuilder = new ResultMap.Builder(configuration, id, type, resultMappings, autoMapping);</span>
<span class="fc bfc" id="L190" title="All 2 branches covered.">    if (extend != null) {</span>
<span class="fc bfc" id="L191" title="All 2 branches covered.">      if (!configuration.hasResultMap(extend)) {</span>
<span class="fc" id="L192">        throw new IncompleteElementException(&quot;Could not find a parent resultmap with id '&quot; + extend + &quot;'&quot;);</span>
      }
<span class="fc" id="L194">      ResultMap resultMap = configuration.getResultMap(extend);</span>
<span class="fc" id="L195">      List&lt;ResultMapping&gt; extendedResultMappings = new ArrayList&lt;ResultMapping&gt;(resultMap.getResultMappings());</span>
<span class="fc" id="L196">      extendedResultMappings.removeAll(resultMappings);</span>
      // Remove parent constructor if this resultMap declares a constructor.
<span class="fc" id="L198">      boolean declaresConstructor = false;</span>
<span class="fc bfc" id="L199" title="All 2 branches covered.">      for (ResultMapping resultMapping : resultMappings) {</span>
<span class="fc bfc" id="L200" title="All 2 branches covered.">        if (resultMapping.getFlags().contains(ResultFlag.CONSTRUCTOR)) {</span>
<span class="fc" id="L201">          declaresConstructor = true;</span>
<span class="fc" id="L202">          break;</span>
        }
<span class="fc" id="L204">      }</span>
<span class="fc bfc" id="L205" title="All 2 branches covered.">      if (declaresConstructor) {</span>
<span class="fc" id="L206">        Iterator&lt;ResultMapping&gt; extendedResultMappingsIter = extendedResultMappings.iterator();</span>
<span class="fc bfc" id="L207" title="All 2 branches covered.">        while (extendedResultMappingsIter.hasNext()) {</span>
<span class="fc bfc" id="L208" title="All 2 branches covered.">          if (extendedResultMappingsIter.next().getFlags().contains(ResultFlag.CONSTRUCTOR)) {</span>
<span class="fc" id="L209">            extendedResultMappingsIter.remove();</span>
          }
        }
      }
<span class="fc" id="L213">      resultMappings.addAll(extendedResultMappings);</span>
    }
<span class="fc" id="L215">    resultMapBuilder.discriminator(discriminator);</span>
<span class="fc" id="L216">    ResultMap resultMap = resultMapBuilder.build();</span>
<span class="fc" id="L217">    configuration.addResultMap(resultMap);</span>
<span class="fc" id="L218">    return resultMap;</span>
  }

  public Discriminator buildDiscriminator(
      Class&lt;?&gt; resultType,
      String column,
      Class&lt;?&gt; javaType,
      JdbcType jdbcType,
      Class&lt;? extends TypeHandler&lt;?&gt;&gt; typeHandler,
      Map&lt;String, String&gt; discriminatorMap) {
<span class="fc" id="L228">    ResultMapping resultMapping = buildResultMapping(</span>
        resultType,
        null,
        column,
        javaType,
        jdbcType,
        null,
        null,
        null,
        null,
        typeHandler,
        new ArrayList&lt;ResultFlag&gt;(),
        null,
        null,
        false);
<span class="fc" id="L243">    Map&lt;String, String&gt; namespaceDiscriminatorMap = new HashMap&lt;String, String&gt;();</span>
<span class="fc bfc" id="L244" title="All 2 branches covered.">    for (Map.Entry&lt;String, String&gt; e : discriminatorMap.entrySet()) {</span>
<span class="fc" id="L245">      String resultMap = e.getValue();</span>
<span class="fc" id="L246">      resultMap = applyCurrentNamespace(resultMap, true);</span>
<span class="fc" id="L247">      namespaceDiscriminatorMap.put(e.getKey(), resultMap);</span>
<span class="fc" id="L248">    }</span>
<span class="fc" id="L249">    Discriminator.Builder discriminatorBuilder = new Discriminator.Builder(configuration, resultMapping, namespaceDiscriminatorMap);</span>
<span class="fc" id="L250">    return discriminatorBuilder.build();</span>
  }

  public MappedStatement addMappedStatement(
      String id,
      SqlSource sqlSource,
      StatementType statementType,
      SqlCommandType sqlCommandType,
      Integer fetchSize,
      Integer timeout,
      String parameterMap,
      Class&lt;?&gt; parameterType,
      String resultMap,
      Class&lt;?&gt; resultType,
      ResultSetType resultSetType,
      boolean flushCache,
      boolean useCache,
      boolean resultOrdered,
      KeyGenerator keyGenerator,
      String keyProperty,
      String keyColumn,
      String databaseId,
      LanguageDriver lang,
      String resultSets) {

<span class="fc bfc" id="L275" title="All 2 branches covered.">    if (unresolvedCacheRef) {</span>
<span class="fc" id="L276">      throw new IncompleteElementException(&quot;Cache-ref not yet resolved&quot;);</span>
    }

<span class="fc" id="L279">    id = applyCurrentNamespace(id, false);</span>
<span class="fc bfc" id="L280" title="All 2 branches covered.">    boolean isSelect = sqlCommandType == SqlCommandType.SELECT;</span>

<span class="fc" id="L282">    MappedStatement.Builder statementBuilder = new MappedStatement.Builder(configuration, id, sqlSource, sqlCommandType);</span>
<span class="fc" id="L283">    statementBuilder.resource(resource);</span>
<span class="fc" id="L284">    statementBuilder.fetchSize(fetchSize);</span>
<span class="fc" id="L285">    statementBuilder.statementType(statementType);</span>
<span class="fc" id="L286">    statementBuilder.keyGenerator(keyGenerator);</span>
<span class="fc" id="L287">    statementBuilder.keyProperty(keyProperty);</span>
<span class="fc" id="L288">    statementBuilder.keyColumn(keyColumn);</span>
<span class="fc" id="L289">    statementBuilder.databaseId(databaseId);</span>
<span class="fc" id="L290">    statementBuilder.lang(lang);</span>
<span class="fc" id="L291">    statementBuilder.resultOrdered(resultOrdered);</span>
<span class="fc" id="L292">    statementBuilder.resulSets(resultSets);</span>
<span class="fc" id="L293">    setStatementTimeout(timeout, statementBuilder);</span>

<span class="fc" id="L295">    setStatementParameterMap(parameterMap, parameterType, statementBuilder);</span>
<span class="fc" id="L296">    setStatementResultMap(resultMap, resultType, resultSetType, statementBuilder);</span>
<span class="fc" id="L297">    setStatementCache(isSelect, flushCache, useCache, currentCache, statementBuilder);</span>

<span class="fc" id="L299">    MappedStatement statement = statementBuilder.build();</span>
<span class="fc" id="L300">    configuration.addMappedStatement(statement);</span>
<span class="fc" id="L301">    return statement;</span>
  }

  private &lt;T&gt; T valueOrDefault(T value, T defaultValue) {
<span class="pc bpc" id="L305" title="1 of 2 branches missed.">    return value == null ? defaultValue : value;</span>
  }

  private void setStatementCache(
      boolean isSelect,
      boolean flushCache,
      boolean useCache,
      Cache cache,
      MappedStatement.Builder statementBuilder) {
<span class="fc bfc" id="L314" title="All 2 branches covered.">    flushCache = valueOrDefault(flushCache, !isSelect);</span>
<span class="fc" id="L315">    useCache = valueOrDefault(useCache, isSelect);</span>
<span class="fc" id="L316">    statementBuilder.flushCacheRequired(flushCache);</span>
<span class="fc" id="L317">    statementBuilder.useCache(useCache);</span>
<span class="fc" id="L318">    statementBuilder.cache(cache);</span>
<span class="fc" id="L319">  }</span>

  private void setStatementParameterMap(
      String parameterMap,
      Class&lt;?&gt; parameterTypeClass,
      MappedStatement.Builder statementBuilder) {
<span class="fc" id="L325">    parameterMap = applyCurrentNamespace(parameterMap, true);</span>

<span class="fc bfc" id="L327" title="All 2 branches covered.">    if (parameterMap != null) {</span>
      try {
<span class="fc" id="L329">        statementBuilder.parameterMap(configuration.getParameterMap(parameterMap));</span>
<span class="fc" id="L330">      } catch (IllegalArgumentException e) {</span>
<span class="fc" id="L331">        throw new IncompleteElementException(&quot;Could not find parameter map &quot; + parameterMap, e);</span>
<span class="fc" id="L332">      }</span>
<span class="fc bfc" id="L333" title="All 2 branches covered.">    } else if (parameterTypeClass != null) {</span>
<span class="fc" id="L334">      List&lt;ParameterMapping&gt; parameterMappings = new ArrayList&lt;ParameterMapping&gt;();</span>
<span class="fc" id="L335">      ParameterMap.Builder inlineParameterMapBuilder = new ParameterMap.Builder(</span>
          configuration,
          statementBuilder.id() + &quot;-Inline&quot;,
          parameterTypeClass,
          parameterMappings);
<span class="fc" id="L340">      statementBuilder.parameterMap(inlineParameterMapBuilder.build());</span>
    }
<span class="fc" id="L342">  }</span>

  private void setStatementResultMap(
      String resultMap,
      Class&lt;?&gt; resultType,
      ResultSetType resultSetType,
      MappedStatement.Builder statementBuilder) {
<span class="fc" id="L349">    resultMap = applyCurrentNamespace(resultMap, true);</span>

<span class="fc" id="L351">    List&lt;ResultMap&gt; resultMaps = new ArrayList&lt;ResultMap&gt;();</span>
<span class="fc bfc" id="L352" title="All 2 branches covered.">    if (resultMap != null) {</span>
<span class="fc" id="L353">      String[] resultMapNames = resultMap.split(&quot;,&quot;);</span>
<span class="fc bfc" id="L354" title="All 2 branches covered.">      for (String resultMapName : resultMapNames) {</span>
        try {
<span class="fc" id="L356">          resultMaps.add(configuration.getResultMap(resultMapName.trim()));</span>
<span class="fc" id="L357">        } catch (IllegalArgumentException e) {</span>
<span class="fc" id="L358">          throw new IncompleteElementException(&quot;Could not find result map &quot; + resultMapName, e);</span>
<span class="fc" id="L359">        }</span>
      }
<span class="fc bfc" id="L361" title="All 2 branches covered.">    } else if (resultType != null) {</span>
<span class="fc" id="L362">      ResultMap.Builder inlineResultMapBuilder = new ResultMap.Builder(</span>
          configuration,
          statementBuilder.id() + &quot;-Inline&quot;,
          resultType,
          new ArrayList&lt;ResultMapping&gt;(),
          null);
<span class="fc" id="L368">      resultMaps.add(inlineResultMapBuilder.build());</span>
    }
<span class="fc" id="L370">    statementBuilder.resultMaps(resultMaps);</span>

<span class="fc" id="L372">    statementBuilder.resultSetType(resultSetType);</span>
<span class="fc" id="L373">  }</span>

  private void setStatementTimeout(Integer timeout, MappedStatement.Builder statementBuilder) {
<span class="pc bpc" id="L376" title="1 of 2 branches missed.">    if (timeout == null) {</span>
<span class="fc" id="L377">      timeout = configuration.getDefaultStatementTimeout();</span>
    }
<span class="fc" id="L379">    statementBuilder.timeout(timeout);</span>
<span class="fc" id="L380">  }</span>

  public ResultMapping buildResultMapping(
      Class&lt;?&gt; resultType,
      String property,
      String column,
      Class&lt;?&gt; javaType,
      JdbcType jdbcType,
      String nestedSelect,
      String nestedResultMap,
      String notNullColumn,
      String columnPrefix,
      Class&lt;? extends TypeHandler&lt;?&gt;&gt; typeHandler,
      List&lt;ResultFlag&gt; flags,
      String resultSet,
      String foreignColumn,
      boolean lazy) {
<span class="fc" id="L397">    Class&lt;?&gt; javaTypeClass = resolveResultJavaType(resultType, property, javaType);</span>
<span class="fc" id="L398">    TypeHandler&lt;?&gt; typeHandlerInstance = resolveTypeHandler(javaTypeClass, typeHandler);</span>
<span class="fc" id="L399">    List&lt;ResultMapping&gt; composites = parseCompositeColumnName(column);</span>
<span class="fc bfc" id="L400" title="All 2 branches covered.">    if (composites.size() &gt; 0) {</span>
<span class="fc" id="L401">      column = null;</span>
    }
<span class="fc" id="L403">    ResultMapping.Builder builder = new ResultMapping.Builder(configuration, property, column, javaTypeClass);</span>
<span class="fc" id="L404">    builder.jdbcType(jdbcType);</span>
<span class="fc" id="L405">    builder.nestedQueryId(applyCurrentNamespace(nestedSelect, true));</span>
<span class="fc" id="L406">    builder.nestedResultMapId(applyCurrentNamespace(nestedResultMap, true));</span>
<span class="fc" id="L407">    builder.resultSet(resultSet);</span>
<span class="fc" id="L408">    builder.typeHandler(typeHandlerInstance);</span>
<span class="pc bpc" id="L409" title="1 of 2 branches missed.">    builder.flags(flags == null ? new ArrayList&lt;ResultFlag&gt;() : flags);</span>
<span class="fc" id="L410">    builder.composites(composites);</span>
<span class="fc" id="L411">    builder.notNullColumns(parseMultipleColumnNames(notNullColumn));</span>
<span class="fc" id="L412">    builder.columnPrefix(columnPrefix);</span>
<span class="fc" id="L413">    builder.foreignColumn(foreignColumn);</span>
<span class="fc" id="L414">    builder.lazy(lazy);</span>
<span class="fc" id="L415">    return builder.build();</span>
  }

  private Set&lt;String&gt; parseMultipleColumnNames(String columnName) {
<span class="fc" id="L419">    Set&lt;String&gt; columns = new HashSet&lt;String&gt;();</span>
<span class="fc bfc" id="L420" title="All 2 branches covered.">    if (columnName != null) {</span>
<span class="fc bfc" id="L421" title="All 2 branches covered.">      if (columnName.indexOf(',') &gt; -1) {</span>
<span class="fc" id="L422">        StringTokenizer parser = new StringTokenizer(columnName, &quot;{}, &quot;, false);</span>
<span class="fc bfc" id="L423" title="All 2 branches covered.">        while (parser.hasMoreTokens()) {</span>
<span class="fc" id="L424">          String column = parser.nextToken();</span>
<span class="fc" id="L425">          columns.add(column);</span>
<span class="fc" id="L426">        }</span>
<span class="fc" id="L427">      } else {</span>
<span class="fc" id="L428">        columns.add(columnName);</span>
      }
    }
<span class="fc" id="L431">    return columns;</span>
  }

  private List&lt;ResultMapping&gt; parseCompositeColumnName(String columnName) {
<span class="fc" id="L435">    List&lt;ResultMapping&gt; composites = new ArrayList&lt;ResultMapping&gt;();</span>
<span class="pc bpc" id="L436" title="1 of 6 branches missed.">    if (columnName != null &amp;&amp; (columnName.indexOf('=') &gt; -1 || columnName.indexOf(',') &gt; -1)) {</span>
<span class="fc" id="L437">      StringTokenizer parser = new StringTokenizer(columnName, &quot;{}=, &quot;, false);</span>
<span class="fc bfc" id="L438" title="All 2 branches covered.">      while (parser.hasMoreTokens()) {</span>
<span class="fc" id="L439">        String property = parser.nextToken();</span>
<span class="fc" id="L440">        String column = parser.nextToken();</span>
<span class="fc" id="L441">        ResultMapping.Builder complexBuilder = new ResultMapping.Builder(configuration, property, column, configuration.getTypeHandlerRegistry().getUnknownTypeHandler());</span>
<span class="fc" id="L442">        composites.add(complexBuilder.build());</span>
<span class="fc" id="L443">      }</span>
    }
<span class="fc" id="L445">    return composites;</span>
  }

  private Class&lt;?&gt; resolveResultJavaType(Class&lt;?&gt; resultType, String property, Class&lt;?&gt; javaType) {
<span class="fc bfc" id="L449" title="All 4 branches covered.">    if (javaType == null &amp;&amp; property != null) {</span>
      try {
<span class="fc" id="L451">        MetaClass metaResultType = MetaClass.forClass(resultType, configuration.getReflectorFactory());</span>
<span class="fc" id="L452">        javaType = metaResultType.getSetterType(property);</span>
<span class="fc" id="L453">      } catch (Exception e) {</span>
        //ignore, following null check statement will deal with the situation
<span class="fc" id="L455">      }</span>
    }
<span class="fc bfc" id="L457" title="All 2 branches covered.">    if (javaType == null) {</span>
<span class="fc" id="L458">      javaType = Object.class;</span>
    }
<span class="fc" id="L460">    return javaType;</span>
  }

  private Class&lt;?&gt; resolveParameterJavaType(Class&lt;?&gt; resultType, String property, Class&lt;?&gt; javaType, JdbcType jdbcType) {
<span class="pc bpc" id="L464" title="1 of 2 branches missed.">    if (javaType == null) {</span>
<span class="pc bpc" id="L465" title="1 of 2 branches missed.">      if (JdbcType.CURSOR.equals(jdbcType)) {</span>
<span class="nc" id="L466">        javaType = java.sql.ResultSet.class;</span>
<span class="fc bfc" id="L467" title="All 2 branches covered.">      } else if (Map.class.isAssignableFrom(resultType)) {</span>
<span class="fc" id="L468">        javaType = Object.class;</span>
      } else {
<span class="fc" id="L470">        MetaClass metaResultType = MetaClass.forClass(resultType, configuration.getReflectorFactory());</span>
<span class="fc" id="L471">        javaType = metaResultType.getGetterType(property);</span>
      }
    }
<span class="pc bpc" id="L474" title="1 of 2 branches missed.">    if (javaType == null) {</span>
<span class="nc" id="L475">      javaType = Object.class;</span>
    }
<span class="fc" id="L477">    return javaType;</span>
  }

  /** Backward compatibility signature */
  public ResultMapping buildResultMapping(
      Class&lt;?&gt; resultType,
      String property,
      String column,
      Class&lt;?&gt; javaType,
      JdbcType jdbcType,
      String nestedSelect,
      String nestedResultMap,
      String notNullColumn,
      String columnPrefix,
      Class&lt;? extends TypeHandler&lt;?&gt;&gt; typeHandler,
      List&lt;ResultFlag&gt; flags) {
<span class="nc" id="L493">      return buildResultMapping(</span>
        resultType, property, column, javaType, jdbcType, nestedSelect,
        nestedResultMap, notNullColumn, columnPrefix, typeHandler, flags, null, null, configuration.isLazyLoadingEnabled());
  }

  public LanguageDriver getLanguageDriver(Class&lt;?&gt; langClass) {
<span class="fc bfc" id="L499" title="All 2 branches covered.">    if (langClass != null) {</span>
<span class="fc" id="L500">      configuration.getLanguageRegistry().register(langClass);</span>
    } else {
<span class="fc" id="L502">      langClass = configuration.getLanguageRegistry().getDefaultDriverClass();</span>
    }
<span class="fc" id="L504">    return configuration.getLanguageRegistry().getDriver(langClass);</span>
  }

  /** Backward compatibility signature */
  public MappedStatement addMappedStatement(
    String id,
    SqlSource sqlSource,
    StatementType statementType,
    SqlCommandType sqlCommandType,
    Integer fetchSize,
    Integer timeout,
    String parameterMap,
    Class&lt;?&gt; parameterType,
    String resultMap,
    Class&lt;?&gt; resultType,
    ResultSetType resultSetType,
    boolean flushCache,
    boolean useCache,
    boolean resultOrdered,
    KeyGenerator keyGenerator,
    String keyProperty,
    String keyColumn,
    String databaseId,
    LanguageDriver lang) {
<span class="nc" id="L528">    return addMappedStatement(</span>
      id, sqlSource, statementType, sqlCommandType, fetchSize, timeout,
      parameterMap, parameterType, resultMap, resultType, resultSetType,
      flushCache, useCache, resultOrdered, keyGenerator, keyProperty,
      keyColumn, databaseId, lang, null);
  }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>