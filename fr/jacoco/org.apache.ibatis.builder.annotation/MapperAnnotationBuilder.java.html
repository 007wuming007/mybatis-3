<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="fr"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MapperAnnotationBuilder.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">mybatis</a> &gt; <a href="index.source.html" class="el_package">org.apache.ibatis.builder.annotation</a> &gt; <span class="el_source">MapperAnnotationBuilder.java</span></div><h1>MapperAnnotationBuilder.java</h1><pre class="source lang-java linenums">/**
 *    Copyright 2009-2019 the original author or authors.
 *
 *    Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */
package org.apache.ibatis.builder.annotation;

import java.io.IOException;
import java.io.InputStream;
import java.lang.annotation.Annotation;
import java.lang.reflect.Array;
import java.lang.reflect.GenericArrayType;
import java.lang.reflect.Method;
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Optional;
import java.util.Properties;
import java.util.Set;

import org.apache.ibatis.annotations.Arg;
import org.apache.ibatis.annotations.CacheNamespace;
import org.apache.ibatis.annotations.CacheNamespaceRef;
import org.apache.ibatis.annotations.Case;
import org.apache.ibatis.annotations.ConstructorArgs;
import org.apache.ibatis.annotations.Delete;
import org.apache.ibatis.annotations.DeleteProvider;
import org.apache.ibatis.annotations.Insert;
import org.apache.ibatis.annotations.InsertProvider;
import org.apache.ibatis.annotations.Lang;
import org.apache.ibatis.annotations.MapKey;
import org.apache.ibatis.annotations.Options;
import org.apache.ibatis.annotations.Options.FlushCachePolicy;
import org.apache.ibatis.annotations.Property;
import org.apache.ibatis.annotations.Result;
import org.apache.ibatis.annotations.ResultMap;
import org.apache.ibatis.annotations.ResultType;
import org.apache.ibatis.annotations.Results;
import org.apache.ibatis.annotations.Select;
import org.apache.ibatis.annotations.SelectKey;
import org.apache.ibatis.annotations.SelectProvider;
import org.apache.ibatis.annotations.TypeDiscriminator;
import org.apache.ibatis.annotations.Update;
import org.apache.ibatis.annotations.UpdateProvider;
import org.apache.ibatis.binding.BindingException;
import org.apache.ibatis.binding.MapperMethod.ParamMap;
import org.apache.ibatis.builder.BuilderException;
import org.apache.ibatis.builder.CacheRefResolver;
import org.apache.ibatis.builder.IncompleteElementException;
import org.apache.ibatis.builder.MapperBuilderAssistant;
import org.apache.ibatis.builder.xml.XMLMapperBuilder;
import org.apache.ibatis.cursor.Cursor;
import org.apache.ibatis.executor.keygen.Jdbc3KeyGenerator;
import org.apache.ibatis.executor.keygen.KeyGenerator;
import org.apache.ibatis.executor.keygen.NoKeyGenerator;
import org.apache.ibatis.executor.keygen.SelectKeyGenerator;
import org.apache.ibatis.io.Resources;
import org.apache.ibatis.mapping.Discriminator;
import org.apache.ibatis.mapping.FetchType;
import org.apache.ibatis.mapping.MappedStatement;
import org.apache.ibatis.mapping.ResultFlag;
import org.apache.ibatis.mapping.ResultMapping;
import org.apache.ibatis.mapping.ResultSetType;
import org.apache.ibatis.mapping.SqlCommandType;
import org.apache.ibatis.mapping.SqlSource;
import org.apache.ibatis.mapping.StatementType;
import org.apache.ibatis.parsing.PropertyParser;
import org.apache.ibatis.reflection.TypeParameterResolver;
import org.apache.ibatis.scripting.LanguageDriver;
import org.apache.ibatis.session.Configuration;
import org.apache.ibatis.session.ResultHandler;
import org.apache.ibatis.session.RowBounds;
import org.apache.ibatis.type.JdbcType;
import org.apache.ibatis.type.TypeHandler;
import org.apache.ibatis.type.UnknownTypeHandler;

/**
 * @author Clinton Begin
 * @author Kazuki Shimizu
 */
public class MapperAnnotationBuilder {

<span class="fc" id="L100">  private static final Set&lt;Class&lt;? extends Annotation&gt;&gt; SQL_ANNOTATION_TYPES = new HashSet&lt;&gt;();</span>
<span class="fc" id="L101">  private static final Set&lt;Class&lt;? extends Annotation&gt;&gt; SQL_PROVIDER_ANNOTATION_TYPES = new HashSet&lt;&gt;();</span>

  private final Configuration configuration;
  private final MapperBuilderAssistant assistant;
  private final Class&lt;?&gt; type;

  static {
<span class="fc" id="L108">    SQL_ANNOTATION_TYPES.add(Select.class);</span>
<span class="fc" id="L109">    SQL_ANNOTATION_TYPES.add(Insert.class);</span>
<span class="fc" id="L110">    SQL_ANNOTATION_TYPES.add(Update.class);</span>
<span class="fc" id="L111">    SQL_ANNOTATION_TYPES.add(Delete.class);</span>

<span class="fc" id="L113">    SQL_PROVIDER_ANNOTATION_TYPES.add(SelectProvider.class);</span>
<span class="fc" id="L114">    SQL_PROVIDER_ANNOTATION_TYPES.add(InsertProvider.class);</span>
<span class="fc" id="L115">    SQL_PROVIDER_ANNOTATION_TYPES.add(UpdateProvider.class);</span>
<span class="fc" id="L116">    SQL_PROVIDER_ANNOTATION_TYPES.add(DeleteProvider.class);</span>
<span class="fc" id="L117">  }</span>

<span class="fc" id="L119">  public MapperAnnotationBuilder(Configuration configuration, Class&lt;?&gt; type) {</span>
<span class="fc" id="L120">    String resource = type.getName().replace('.', '/') + &quot;.java (best guess)&quot;;</span>
<span class="fc" id="L121">    this.assistant = new MapperBuilderAssistant(configuration, resource);</span>
<span class="fc" id="L122">    this.configuration = configuration;</span>
<span class="fc" id="L123">    this.type = type;</span>
<span class="fc" id="L124">  }</span>

  public void parse() {
<span class="fc" id="L127">    String resource = type.toString();</span>
<span class="pc bpc" id="L128" title="1 of 2 branches missed.">    if (!configuration.isResourceLoaded(resource)) {</span>
<span class="fc" id="L129">      loadXmlResource();</span>
<span class="fc" id="L130">      configuration.addLoadedResource(resource);</span>
<span class="fc" id="L131">      assistant.setCurrentNamespace(type.getName());</span>
<span class="fc" id="L132">      parseCache();</span>
<span class="fc" id="L133">      parseCacheRef();</span>
<span class="fc" id="L134">      Method[] methods = type.getMethods();</span>
<span class="fc bfc" id="L135" title="All 2 branches covered.">      for (Method method : methods) {</span>
        try {
          // issue #237
<span class="fc bfc" id="L138" title="All 2 branches covered.">          if (!method.isBridge()) {</span>
<span class="fc" id="L139">            parseStatement(method);</span>
          }
<span class="fc" id="L141">        } catch (IncompleteElementException e) {</span>
<span class="fc" id="L142">          configuration.addIncompleteMethod(new MethodResolver(this, method));</span>
        }
      }
    }
<span class="fc" id="L146">    parsePendingMethods();</span>
<span class="fc" id="L147">  }</span>

  private void parsePendingMethods() {
<span class="fc" id="L150">    Collection&lt;MethodResolver&gt; incompleteMethods = configuration.getIncompleteMethods();</span>
<span class="fc" id="L151">    synchronized (incompleteMethods) {</span>
<span class="fc" id="L152">      Iterator&lt;MethodResolver&gt; iter = incompleteMethods.iterator();</span>
<span class="fc bfc" id="L153" title="All 2 branches covered.">      while (iter.hasNext()) {</span>
        try {
<span class="fc" id="L155">          iter.next().resolve();</span>
<span class="fc" id="L156">          iter.remove();</span>
<span class="fc" id="L157">        } catch (IncompleteElementException e) {</span>
          // This method is still missing a resource
        }
      }
    }
<span class="fc" id="L162">  }</span>

  private void loadXmlResource() {
    // Spring may not know the real resource name so we check a flag
    // to prevent loading again a resource twice
    // this flag is set at XMLMapperBuilder#bindMapperForNamespace
<span class="fc bfc" id="L168" title="All 2 branches covered.">    if (!configuration.isResourceLoaded(&quot;namespace:&quot; + type.getName())) {</span>
<span class="fc" id="L169">      String xmlResource = type.getName().replace('.', '/') + &quot;.xml&quot;;</span>
      // #1347
<span class="fc" id="L171">      InputStream inputStream = type.getResourceAsStream(&quot;/&quot; + xmlResource);</span>
<span class="fc bfc" id="L172" title="All 2 branches covered.">      if (inputStream == null) {</span>
        // Search XML mapper that is not in the module but in the classpath.
        try {
<span class="nc" id="L175">          inputStream = Resources.getResourceAsStream(type.getClassLoader(), xmlResource);</span>
<span class="pc" id="L176">        } catch (IOException e2) {</span>
          // ignore, resource is not required
        }
      }
<span class="fc bfc" id="L180" title="All 2 branches covered.">      if (inputStream != null) {</span>
<span class="fc" id="L181">        XMLMapperBuilder xmlParser = new XMLMapperBuilder(inputStream, assistant.getConfiguration(), xmlResource, configuration.getSqlFragments(), type.getName());</span>
<span class="fc" id="L182">        xmlParser.parse();</span>
      }
    }
<span class="fc" id="L185">  }</span>

  private void parseCache() {
<span class="fc" id="L188">    CacheNamespace cacheDomain = type.getAnnotation(CacheNamespace.class);</span>
<span class="fc bfc" id="L189" title="All 2 branches covered.">    if (cacheDomain != null) {</span>
<span class="pc bpc" id="L190" title="1 of 2 branches missed.">      Integer size = cacheDomain.size() == 0 ? null : cacheDomain.size();</span>
<span class="pc bpc" id="L191" title="1 of 2 branches missed.">      Long flushInterval = cacheDomain.flushInterval() == 0 ? null : cacheDomain.flushInterval();</span>
<span class="fc" id="L192">      Properties props = convertToProperties(cacheDomain.properties());</span>
<span class="fc" id="L193">      assistant.useNewCache(cacheDomain.implementation(), cacheDomain.eviction(), flushInterval, size, cacheDomain.readWrite(), cacheDomain.blocking(), props);</span>
    }
<span class="fc" id="L195">  }</span>

  private Properties convertToProperties(Property[] properties) {
<span class="fc bfc" id="L198" title="All 2 branches covered.">    if (properties.length == 0) {</span>
<span class="fc" id="L199">      return null;</span>
    }
<span class="fc" id="L201">    Properties props = new Properties();</span>
<span class="fc bfc" id="L202" title="All 2 branches covered.">    for (Property property : properties) {</span>
<span class="fc" id="L203">      props.setProperty(property.name(),</span>
<span class="fc" id="L204">          PropertyParser.parse(property.value(), configuration.getVariables()));</span>
    }
<span class="fc" id="L206">    return props;</span>
  }

  private void parseCacheRef() {
<span class="fc" id="L210">    CacheNamespaceRef cacheDomainRef = type.getAnnotation(CacheNamespaceRef.class);</span>
<span class="fc bfc" id="L211" title="All 2 branches covered.">    if (cacheDomainRef != null) {</span>
<span class="fc" id="L212">      Class&lt;?&gt; refType = cacheDomainRef.value();</span>
<span class="fc" id="L213">      String refName = cacheDomainRef.name();</span>
<span class="fc bfc" id="L214" title="All 4 branches covered.">      if (refType == void.class &amp;&amp; refName.isEmpty()) {</span>
<span class="fc" id="L215">        throw new BuilderException(&quot;Should be specified either value() or name() attribute in the @CacheNamespaceRef&quot;);</span>
      }
<span class="fc bfc" id="L217" title="All 4 branches covered.">      if (refType != void.class &amp;&amp; !refName.isEmpty()) {</span>
<span class="fc" id="L218">        throw new BuilderException(&quot;Cannot use both value() and name() attribute in the @CacheNamespaceRef&quot;);</span>
      }
<span class="fc bfc" id="L220" title="All 2 branches covered.">      String namespace = (refType != void.class) ? refType.getName() : refName;</span>
      try {
<span class="fc" id="L222">        assistant.useCacheRef(namespace);</span>
<span class="fc" id="L223">      } catch (IncompleteElementException e) {</span>
<span class="fc" id="L224">        configuration.addIncompleteCacheRef(new CacheRefResolver(assistant, namespace));</span>
      }
    }
<span class="fc" id="L227">  }</span>

  private String parseResultMap(Method method) {
<span class="fc" id="L230">    Class&lt;?&gt; returnType = getReturnType(method);</span>
<span class="fc" id="L231">    ConstructorArgs args = method.getAnnotation(ConstructorArgs.class);</span>
<span class="fc" id="L232">    Results results = method.getAnnotation(Results.class);</span>
<span class="fc" id="L233">    TypeDiscriminator typeDiscriminator = method.getAnnotation(TypeDiscriminator.class);</span>
<span class="fc" id="L234">    String resultMapId = generateResultMapName(method);</span>
<span class="fc" id="L235">    applyResultMap(resultMapId, returnType, argsIf(args), resultsIf(results), typeDiscriminator);</span>
<span class="fc" id="L236">    return resultMapId;</span>
  }

  private String generateResultMapName(Method method) {
<span class="fc" id="L240">    Results results = method.getAnnotation(Results.class);</span>
<span class="fc bfc" id="L241" title="All 4 branches covered.">    if (results != null &amp;&amp; !results.id().isEmpty()) {</span>
<span class="fc" id="L242">      return type.getName() + &quot;.&quot; + results.id();</span>
    }
<span class="fc" id="L244">    StringBuilder suffix = new StringBuilder();</span>
<span class="fc bfc" id="L245" title="All 2 branches covered.">    for (Class&lt;?&gt; c : method.getParameterTypes()) {</span>
<span class="fc" id="L246">      suffix.append(&quot;-&quot;);</span>
<span class="fc" id="L247">      suffix.append(c.getSimpleName());</span>
    }
<span class="fc bfc" id="L249" title="All 2 branches covered.">    if (suffix.length() &lt; 1) {</span>
<span class="fc" id="L250">      suffix.append(&quot;-void&quot;);</span>
    }
<span class="fc" id="L252">    return type.getName() + &quot;.&quot; + method.getName() + suffix;</span>
  }

  private void applyResultMap(String resultMapId, Class&lt;?&gt; returnType, Arg[] args, Result[] results, TypeDiscriminator discriminator) {
<span class="fc" id="L256">    List&lt;ResultMapping&gt; resultMappings = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L257">    applyConstructorArgs(args, returnType, resultMappings);</span>
<span class="fc" id="L258">    applyResults(results, returnType, resultMappings);</span>
<span class="fc" id="L259">    Discriminator disc = applyDiscriminator(resultMapId, returnType, discriminator);</span>
    // TODO add AutoMappingBehaviour
<span class="fc" id="L261">    assistant.addResultMap(resultMapId, returnType, null, disc, resultMappings, null);</span>
<span class="fc" id="L262">    createDiscriminatorResultMaps(resultMapId, returnType, discriminator);</span>
<span class="fc" id="L263">  }</span>

  private void createDiscriminatorResultMaps(String resultMapId, Class&lt;?&gt; resultType, TypeDiscriminator discriminator) {
<span class="fc bfc" id="L266" title="All 2 branches covered.">    if (discriminator != null) {</span>
<span class="fc bfc" id="L267" title="All 2 branches covered.">      for (Case c : discriminator.cases()) {</span>
<span class="fc" id="L268">        String caseResultMapId = resultMapId + &quot;-&quot; + c.value();</span>
<span class="fc" id="L269">        List&lt;ResultMapping&gt; resultMappings = new ArrayList&lt;&gt;();</span>
        // issue #136
<span class="fc" id="L271">        applyConstructorArgs(c.constructArgs(), resultType, resultMappings);</span>
<span class="fc" id="L272">        applyResults(c.results(), resultType, resultMappings);</span>
        // TODO add AutoMappingBehaviour
<span class="fc" id="L274">        assistant.addResultMap(caseResultMapId, c.type(), resultMapId, null, resultMappings, null);</span>
      }
    }
<span class="fc" id="L277">  }</span>

  private Discriminator applyDiscriminator(String resultMapId, Class&lt;?&gt; resultType, TypeDiscriminator discriminator) {
<span class="fc bfc" id="L280" title="All 2 branches covered.">    if (discriminator != null) {</span>
<span class="fc" id="L281">      String column = discriminator.column();</span>
<span class="pc bpc" id="L282" title="1 of 2 branches missed.">      Class&lt;?&gt; javaType = discriminator.javaType() == void.class ? String.class : discriminator.javaType();</span>
<span class="pc bpc" id="L283" title="1 of 2 branches missed.">      JdbcType jdbcType = discriminator.jdbcType() == JdbcType.UNDEFINED ? null : discriminator.jdbcType();</span>
      @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L285">      Class&lt;? extends TypeHandler&lt;?&gt;&gt; typeHandler = (Class&lt;? extends TypeHandler&lt;?&gt;&gt;)</span>
<span class="fc bfc" id="L286" title="All 2 branches covered.">              (discriminator.typeHandler() == UnknownTypeHandler.class ? null : discriminator.typeHandler());</span>
<span class="fc" id="L287">      Case[] cases = discriminator.cases();</span>
<span class="fc" id="L288">      Map&lt;String, String&gt; discriminatorMap = new HashMap&lt;&gt;();</span>
<span class="fc bfc" id="L289" title="All 2 branches covered.">      for (Case c : cases) {</span>
<span class="fc" id="L290">        String value = c.value();</span>
<span class="fc" id="L291">        String caseResultMapId = resultMapId + &quot;-&quot; + value;</span>
<span class="fc" id="L292">        discriminatorMap.put(value, caseResultMapId);</span>
      }
<span class="fc" id="L294">      return assistant.buildDiscriminator(resultType, column, javaType, jdbcType, typeHandler, discriminatorMap);</span>
    }
<span class="fc" id="L296">    return null;</span>
  }

  void parseStatement(Method method) {
<span class="fc" id="L300">    Class&lt;?&gt; parameterTypeClass = getParameterType(method);</span>
<span class="fc" id="L301">    LanguageDriver languageDriver = getLanguageDriver(method);</span>
<span class="fc" id="L302">    SqlSource sqlSource = getSqlSourceFromAnnotations(method, parameterTypeClass, languageDriver);</span>
<span class="fc bfc" id="L303" title="All 2 branches covered.">    if (sqlSource != null) {</span>
<span class="fc" id="L304">      Options options = method.getAnnotation(Options.class);</span>
<span class="fc" id="L305">      final String mappedStatementId = type.getName() + &quot;.&quot; + method.getName();</span>
<span class="fc" id="L306">      Integer fetchSize = null;</span>
<span class="fc" id="L307">      Integer timeout = null;</span>
<span class="fc" id="L308">      StatementType statementType = StatementType.PREPARED;</span>
<span class="fc" id="L309">      ResultSetType resultSetType = null;</span>
<span class="fc" id="L310">      SqlCommandType sqlCommandType = getSqlCommandType(method);</span>
<span class="fc bfc" id="L311" title="All 2 branches covered.">      boolean isSelect = sqlCommandType == SqlCommandType.SELECT;</span>
<span class="fc bfc" id="L312" title="All 2 branches covered.">      boolean flushCache = !isSelect;</span>
<span class="fc" id="L313">      boolean useCache = isSelect;</span>

      KeyGenerator keyGenerator;
<span class="fc" id="L316">      String keyProperty = null;</span>
<span class="fc" id="L317">      String keyColumn = null;</span>
<span class="fc bfc" id="L318" title="All 4 branches covered.">      if (SqlCommandType.INSERT.equals(sqlCommandType) || SqlCommandType.UPDATE.equals(sqlCommandType)) {</span>
        // first check for SelectKey annotation - that overrides everything else
<span class="fc" id="L320">        SelectKey selectKey = method.getAnnotation(SelectKey.class);</span>
<span class="fc bfc" id="L321" title="All 2 branches covered.">        if (selectKey != null) {</span>
<span class="fc" id="L322">          keyGenerator = handleSelectKeyAnnotation(selectKey, mappedStatementId, getParameterType(method), languageDriver);</span>
<span class="fc" id="L323">          keyProperty = selectKey.keyProperty();</span>
<span class="fc bfc" id="L324" title="All 2 branches covered.">        } else if (options == null) {</span>
<span class="fc bfc" id="L325" title="All 2 branches covered.">          keyGenerator = configuration.isUseGeneratedKeys() ? Jdbc3KeyGenerator.INSTANCE : NoKeyGenerator.INSTANCE;</span>
<span class="fc" id="L326">        } else {</span>
<span class="fc bfc" id="L327" title="All 2 branches covered.">          keyGenerator = options.useGeneratedKeys() ? Jdbc3KeyGenerator.INSTANCE : NoKeyGenerator.INSTANCE;</span>
<span class="fc" id="L328">          keyProperty = options.keyProperty();</span>
<span class="fc" id="L329">          keyColumn = options.keyColumn();</span>
        }
<span class="fc" id="L331">      } else {</span>
<span class="fc" id="L332">        keyGenerator = NoKeyGenerator.INSTANCE;</span>
      }

<span class="fc bfc" id="L335" title="All 2 branches covered.">      if (options != null) {</span>
<span class="fc bfc" id="L336" title="All 2 branches covered.">        if (FlushCachePolicy.TRUE.equals(options.flushCache())) {</span>
<span class="fc" id="L337">          flushCache = true;</span>
<span class="fc bfc" id="L338" title="All 2 branches covered.">        } else if (FlushCachePolicy.FALSE.equals(options.flushCache())) {</span>
<span class="fc" id="L339">          flushCache = false;</span>
        }
<span class="fc" id="L341">        useCache = options.useCache();</span>
<span class="pc bpc" id="L342" title="2 of 4 branches missed.">        fetchSize = options.fetchSize() &gt; -1 || options.fetchSize() == Integer.MIN_VALUE ? options.fetchSize() : null; //issue #348</span>
<span class="pc bpc" id="L343" title="1 of 2 branches missed.">        timeout = options.timeout() &gt; -1 ? options.timeout() : null;</span>
<span class="fc" id="L344">        statementType = options.statementType();</span>
<span class="fc" id="L345">        resultSetType = options.resultSetType();</span>
      }

<span class="fc" id="L348">      String resultMapId = null;</span>
<span class="fc" id="L349">      ResultMap resultMapAnnotation = method.getAnnotation(ResultMap.class);</span>
<span class="fc bfc" id="L350" title="All 2 branches covered.">      if (resultMapAnnotation != null) {</span>
<span class="fc" id="L351">        resultMapId = String.join(&quot;,&quot;, resultMapAnnotation.value());</span>
<span class="fc bfc" id="L352" title="All 2 branches covered.">      } else if (isSelect) {</span>
<span class="fc" id="L353">        resultMapId = parseResultMap(method);</span>
      }

<span class="fc" id="L356">      assistant.addMappedStatement(</span>
<span class="fc" id="L357">          mappedStatementId,</span>
<span class="fc" id="L358">          sqlSource,</span>
<span class="fc" id="L359">          statementType,</span>
<span class="fc" id="L360">          sqlCommandType,</span>
<span class="fc" id="L361">          fetchSize,</span>
<span class="fc" id="L362">          timeout,</span>
          // ParameterMapID
<span class="fc" id="L364">          null,</span>
<span class="fc" id="L365">          parameterTypeClass,</span>
<span class="fc" id="L366">          resultMapId,</span>
<span class="fc" id="L367">          getReturnType(method),</span>
<span class="fc" id="L368">          resultSetType,</span>
<span class="fc" id="L369">          flushCache,</span>
<span class="fc" id="L370">          useCache,</span>
          // TODO gcode issue #577
<span class="fc" id="L372">          false,</span>
<span class="fc" id="L373">          keyGenerator,</span>
<span class="fc" id="L374">          keyProperty,</span>
<span class="fc" id="L375">          keyColumn,</span>
          // DatabaseID
<span class="fc" id="L377">          null,</span>
<span class="fc" id="L378">          languageDriver,</span>
          // ResultSets
<span class="fc bfc" id="L380" title="All 2 branches covered.">          options != null ? nullOrEmpty(options.resultSets()) : null);</span>
    }
<span class="fc" id="L382">  }</span>

  private LanguageDriver getLanguageDriver(Method method) {
<span class="fc" id="L385">    Lang lang = method.getAnnotation(Lang.class);</span>
<span class="fc" id="L386">    Class&lt;? extends LanguageDriver&gt; langClass = null;</span>
<span class="fc bfc" id="L387" title="All 2 branches covered.">    if (lang != null) {</span>
<span class="fc" id="L388">      langClass = lang.value();</span>
    }
<span class="fc" id="L390">    return configuration.getLanguageDriver(langClass);</span>
  }

  private Class&lt;?&gt; getParameterType(Method method) {
<span class="fc" id="L394">    Class&lt;?&gt; parameterType = null;</span>
<span class="fc" id="L395">    Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();</span>
<span class="fc bfc" id="L396" title="All 2 branches covered.">    for (Class&lt;?&gt; currentParameterType : parameterTypes) {</span>
<span class="fc bfc" id="L397" title="All 4 branches covered.">      if (!RowBounds.class.isAssignableFrom(currentParameterType) &amp;&amp; !ResultHandler.class.isAssignableFrom(currentParameterType)) {</span>
<span class="fc bfc" id="L398" title="All 2 branches covered.">        if (parameterType == null) {</span>
<span class="fc" id="L399">          parameterType = currentParameterType;</span>
<span class="fc" id="L400">        } else {</span>
          // issue #135
<span class="fc" id="L402">          parameterType = ParamMap.class;</span>
        }
      }
    }
<span class="fc" id="L406">    return parameterType;</span>
  }

  private Class&lt;?&gt; getReturnType(Method method) {
<span class="fc" id="L410">    Class&lt;?&gt; returnType = method.getReturnType();</span>
<span class="fc" id="L411">    Type resolvedReturnType = TypeParameterResolver.resolveReturnType(method, type);</span>
<span class="fc bfc" id="L412" title="All 2 branches covered.">    if (resolvedReturnType instanceof Class) {</span>
<span class="fc" id="L413">      returnType = (Class&lt;?&gt;) resolvedReturnType;</span>
<span class="fc bfc" id="L414" title="All 2 branches covered.">      if (returnType.isArray()) {</span>
<span class="fc" id="L415">        returnType = returnType.getComponentType();</span>
      }
      // gcode issue #508
<span class="fc bfc" id="L418" title="All 2 branches covered.">      if (void.class.equals(returnType)) {</span>
<span class="fc" id="L419">        ResultType rt = method.getAnnotation(ResultType.class);</span>
<span class="fc bfc" id="L420" title="All 2 branches covered.">        if (rt != null) {</span>
<span class="fc" id="L421">          returnType = rt.value();</span>
        }
      }
<span class="pc bpc" id="L424" title="1 of 2 branches missed.">    } else if (resolvedReturnType instanceof ParameterizedType) {</span>
<span class="fc" id="L425">      ParameterizedType parameterizedType = (ParameterizedType) resolvedReturnType;</span>
<span class="fc" id="L426">      Class&lt;?&gt; rawType = (Class&lt;?&gt;) parameterizedType.getRawType();</span>
<span class="fc bfc" id="L427" title="All 4 branches covered.">      if (Collection.class.isAssignableFrom(rawType) || Cursor.class.isAssignableFrom(rawType)) {</span>
<span class="fc" id="L428">        Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();</span>
<span class="pc bpc" id="L429" title="2 of 4 branches missed.">        if (actualTypeArguments != null &amp;&amp; actualTypeArguments.length == 1) {</span>
<span class="fc" id="L430">          Type returnTypeParameter = actualTypeArguments[0];</span>
<span class="fc bfc" id="L431" title="All 2 branches covered.">          if (returnTypeParameter instanceof Class&lt;?&gt;) {</span>
<span class="fc" id="L432">            returnType = (Class&lt;?&gt;) returnTypeParameter;</span>
<span class="pc bpc" id="L433" title="1 of 2 branches missed.">          } else if (returnTypeParameter instanceof ParameterizedType) {</span>
            // (gcode issue #443) actual type can be a also a parameterized type
<span class="fc" id="L435">            returnType = (Class&lt;?&gt;) ((ParameterizedType) returnTypeParameter).getRawType();</span>
<span class="pc bnc" id="L436" title="All 2 branches missed.">          } else if (returnTypeParameter instanceof GenericArrayType) {</span>
<span class="nc" id="L437">            Class&lt;?&gt; componentType = (Class&lt;?&gt;) ((GenericArrayType) returnTypeParameter).getGenericComponentType();</span>
            // (gcode issue #525) support List&lt;byte[]&gt;
<span class="nc" id="L439">            returnType = Array.newInstance(componentType, 0).getClass();</span>
          }
        }
<span class="pc bpc" id="L442" title="1 of 4 branches missed.">      } else if (method.isAnnotationPresent(MapKey.class) &amp;&amp; Map.class.isAssignableFrom(rawType)) {</span>
        // (gcode issue 504) Do not look into Maps if there is not MapKey annotation
<span class="fc" id="L444">        Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();</span>
<span class="pc bpc" id="L445" title="2 of 4 branches missed.">        if (actualTypeArguments != null &amp;&amp; actualTypeArguments.length == 2) {</span>
<span class="fc" id="L446">          Type returnTypeParameter = actualTypeArguments[1];</span>
<span class="fc bfc" id="L447" title="All 2 branches covered.">          if (returnTypeParameter instanceof Class&lt;?&gt;) {</span>
<span class="fc" id="L448">            returnType = (Class&lt;?&gt;) returnTypeParameter;</span>
<span class="pc bpc" id="L449" title="1 of 2 branches missed.">          } else if (returnTypeParameter instanceof ParameterizedType) {</span>
            // (gcode issue 443) actual type can be a also a parameterized type
<span class="fc" id="L451">            returnType = (Class&lt;?&gt;) ((ParameterizedType) returnTypeParameter).getRawType();</span>
          }
        }
<span class="fc bfc" id="L454" title="All 2 branches covered.">      } else if (Optional.class.equals(rawType)) {</span>
<span class="fc" id="L455">        Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();</span>
<span class="fc" id="L456">        Type returnTypeParameter = actualTypeArguments[0];</span>
<span class="pc bpc" id="L457" title="1 of 2 branches missed.">        if (returnTypeParameter instanceof Class&lt;?&gt;) {</span>
<span class="fc" id="L458">          returnType = (Class&lt;?&gt;) returnTypeParameter;</span>
        }
      }
    }

<span class="fc" id="L463">    return returnType;</span>
  }

  private SqlSource getSqlSourceFromAnnotations(Method method, Class&lt;?&gt; parameterType, LanguageDriver languageDriver) {
    try {
<span class="fc" id="L468">      Class&lt;? extends Annotation&gt; sqlAnnotationType = getSqlAnnotationType(method);</span>
<span class="fc" id="L469">      Class&lt;? extends Annotation&gt; sqlProviderAnnotationType = getSqlProviderAnnotationType(method);</span>
<span class="fc bfc" id="L470" title="All 2 branches covered.">      if (sqlAnnotationType != null) {</span>
<span class="pc bpc" id="L471" title="1 of 2 branches missed.">        if (sqlProviderAnnotationType != null) {</span>
<span class="nc" id="L472">          throw new BindingException(&quot;You cannot supply both a static SQL and SqlProvider to method named &quot; + method.getName());</span>
        }
<span class="fc" id="L474">        Annotation sqlAnnotation = method.getAnnotation(sqlAnnotationType);</span>
<span class="fc" id="L475">        final String[] strings = (String[]) sqlAnnotation.getClass().getMethod(&quot;value&quot;).invoke(sqlAnnotation);</span>
<span class="fc" id="L476">        return buildSqlSourceFromStrings(strings, parameterType, languageDriver);</span>
<span class="fc bfc" id="L477" title="All 2 branches covered.">      } else if (sqlProviderAnnotationType != null) {</span>
<span class="fc" id="L478">        Annotation sqlProviderAnnotation = method.getAnnotation(sqlProviderAnnotationType);</span>
<span class="fc" id="L479">        return new ProviderSqlSource(assistant.getConfiguration(), sqlProviderAnnotation, type, method);</span>
      }
<span class="fc" id="L481">      return null;</span>
<span class="nc" id="L482">    } catch (Exception e) {</span>
<span class="nc" id="L483">      throw new BuilderException(&quot;Could not find value method on SQL annotation.  Cause: &quot; + e, e);</span>
    }
  }

  private SqlSource buildSqlSourceFromStrings(String[] strings, Class&lt;?&gt; parameterTypeClass, LanguageDriver languageDriver) {
<span class="fc" id="L488">    final StringBuilder sql = new StringBuilder();</span>
<span class="fc bfc" id="L489" title="All 2 branches covered.">    for (String fragment : strings) {</span>
<span class="fc" id="L490">      sql.append(fragment);</span>
<span class="fc" id="L491">      sql.append(&quot; &quot;);</span>
    }
<span class="fc" id="L493">    return languageDriver.createSqlSource(configuration, sql.toString().trim(), parameterTypeClass);</span>
  }

  private SqlCommandType getSqlCommandType(Method method) {
<span class="fc" id="L497">    Class&lt;? extends Annotation&gt; type = getSqlAnnotationType(method);</span>

<span class="fc bfc" id="L499" title="All 2 branches covered.">    if (type == null) {</span>
<span class="fc" id="L500">      type = getSqlProviderAnnotationType(method);</span>

<span class="pc bpc" id="L502" title="1 of 2 branches missed.">      if (type == null) {</span>
<span class="nc" id="L503">        return SqlCommandType.UNKNOWN;</span>
      }

<span class="fc bfc" id="L506" title="All 2 branches covered.">      if (type == SelectProvider.class) {</span>
<span class="fc" id="L507">        type = Select.class;</span>
<span class="fc bfc" id="L508" title="All 2 branches covered.">      } else if (type == InsertProvider.class) {</span>
<span class="fc" id="L509">        type = Insert.class;</span>
<span class="fc bfc" id="L510" title="All 2 branches covered.">      } else if (type == UpdateProvider.class) {</span>
<span class="fc" id="L511">        type = Update.class;</span>
<span class="pc bpc" id="L512" title="1 of 2 branches missed.">      } else if (type == DeleteProvider.class) {</span>
<span class="fc" id="L513">        type = Delete.class;</span>
      }
    }

<span class="fc" id="L517">    return SqlCommandType.valueOf(type.getSimpleName().toUpperCase(Locale.ENGLISH));</span>
  }

  private Class&lt;? extends Annotation&gt; getSqlAnnotationType(Method method) {
<span class="fc" id="L521">    return chooseAnnotationType(method, SQL_ANNOTATION_TYPES);</span>
  }

  private Class&lt;? extends Annotation&gt; getSqlProviderAnnotationType(Method method) {
<span class="fc" id="L525">    return chooseAnnotationType(method, SQL_PROVIDER_ANNOTATION_TYPES);</span>
  }

  private Class&lt;? extends Annotation&gt; chooseAnnotationType(Method method, Set&lt;Class&lt;? extends Annotation&gt;&gt; types) {
<span class="fc bfc" id="L529" title="All 2 branches covered.">    for (Class&lt;? extends Annotation&gt; type : types) {</span>
<span class="fc" id="L530">      Annotation annotation = method.getAnnotation(type);</span>
<span class="fc bfc" id="L531" title="All 2 branches covered.">      if (annotation != null) {</span>
<span class="fc" id="L532">        return type;</span>
      }
    }
<span class="fc" id="L535">    return null;</span>
  }

  private void applyResults(Result[] results, Class&lt;?&gt; resultType, List&lt;ResultMapping&gt; resultMappings) {
<span class="fc bfc" id="L539" title="All 2 branches covered.">    for (Result result : results) {</span>
<span class="fc" id="L540">      List&lt;ResultFlag&gt; flags = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L541" title="All 2 branches covered.">      if (result.id()) {</span>
<span class="fc" id="L542">        flags.add(ResultFlag.ID);</span>
      }
      @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L545">      Class&lt;? extends TypeHandler&lt;?&gt;&gt; typeHandler = (Class&lt;? extends TypeHandler&lt;?&gt;&gt;)</span>
<span class="fc bfc" id="L546" title="All 2 branches covered.">              ((result.typeHandler() == UnknownTypeHandler.class) ? null : result.typeHandler());</span>
<span class="fc" id="L547">      ResultMapping resultMapping = assistant.buildResultMapping(</span>
<span class="fc" id="L548">          resultType,</span>
<span class="fc" id="L549">          nullOrEmpty(result.property()),</span>
<span class="fc" id="L550">          nullOrEmpty(result.column()),</span>
<span class="fc bfc" id="L551" title="All 2 branches covered.">          result.javaType() == void.class ? null : result.javaType(),</span>
<span class="fc bfc" id="L552" title="All 2 branches covered.">          result.jdbcType() == JdbcType.UNDEFINED ? null : result.jdbcType(),</span>
<span class="fc bfc" id="L553" title="All 2 branches covered.">          hasNestedSelect(result) ? nestedSelectId(result) : null,</span>
<span class="fc" id="L554">          null,</span>
<span class="fc" id="L555">          null,</span>
<span class="fc" id="L556">          null,</span>
<span class="fc" id="L557">          typeHandler,</span>
<span class="fc" id="L558">          flags,</span>
<span class="fc" id="L559">          null,</span>
<span class="fc" id="L560">          null,</span>
<span class="fc" id="L561">          isLazy(result));</span>
<span class="fc" id="L562">      resultMappings.add(resultMapping);</span>
    }
<span class="fc" id="L564">  }</span>

  private String nestedSelectId(Result result) {
<span class="fc" id="L567">    String nestedSelect = result.one().select();</span>
<span class="fc bfc" id="L568" title="All 2 branches covered.">    if (nestedSelect.length() &lt; 1) {</span>
<span class="fc" id="L569">      nestedSelect = result.many().select();</span>
    }
<span class="fc bfc" id="L571" title="All 2 branches covered.">    if (!nestedSelect.contains(&quot;.&quot;)) {</span>
<span class="fc" id="L572">      nestedSelect = type.getName() + &quot;.&quot; + nestedSelect;</span>
    }
<span class="fc" id="L574">    return nestedSelect;</span>
  }

  private boolean isLazy(Result result) {
<span class="fc" id="L578">    boolean isLazy = configuration.isLazyLoadingEnabled();</span>
<span class="fc bfc" id="L579" title="All 4 branches covered.">    if (result.one().select().length() &gt; 0 &amp;&amp; FetchType.DEFAULT != result.one().fetchType()) {</span>
<span class="pc bpc" id="L580" title="1 of 2 branches missed.">      isLazy = result.one().fetchType() == FetchType.LAZY;</span>
<span class="fc bfc" id="L581" title="All 4 branches covered.">    } else if (result.many().select().length() &gt; 0 &amp;&amp; FetchType.DEFAULT != result.many().fetchType()) {</span>
<span class="pc bpc" id="L582" title="1 of 2 branches missed.">      isLazy = result.many().fetchType() == FetchType.LAZY;</span>
    }
<span class="fc" id="L584">    return isLazy;</span>
  }

  private boolean hasNestedSelect(Result result) {
<span class="fc bfc" id="L588" title="All 4 branches covered.">    if (result.one().select().length() &gt; 0 &amp;&amp; result.many().select().length() &gt; 0) {</span>
<span class="fc" id="L589">      throw new BuilderException(&quot;Cannot use both @One and @Many annotations in the same @Result&quot;);</span>
    }
<span class="fc bfc" id="L591" title="All 4 branches covered.">    return result.one().select().length() &gt; 0 || result.many().select().length() &gt; 0;</span>
  }

  private void applyConstructorArgs(Arg[] args, Class&lt;?&gt; resultType, List&lt;ResultMapping&gt; resultMappings) {
<span class="fc bfc" id="L595" title="All 2 branches covered.">    for (Arg arg : args) {</span>
<span class="fc" id="L596">      List&lt;ResultFlag&gt; flags = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L597">      flags.add(ResultFlag.CONSTRUCTOR);</span>
<span class="fc bfc" id="L598" title="All 2 branches covered.">      if (arg.id()) {</span>
<span class="fc" id="L599">        flags.add(ResultFlag.ID);</span>
      }
      @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L602">      Class&lt;? extends TypeHandler&lt;?&gt;&gt; typeHandler = (Class&lt;? extends TypeHandler&lt;?&gt;&gt;)</span>
<span class="fc bfc" id="L603" title="All 2 branches covered.">              (arg.typeHandler() == UnknownTypeHandler.class ? null : arg.typeHandler());</span>
<span class="fc" id="L604">      ResultMapping resultMapping = assistant.buildResultMapping(</span>
<span class="fc" id="L605">          resultType,</span>
<span class="fc" id="L606">          nullOrEmpty(arg.name()),</span>
<span class="fc" id="L607">          nullOrEmpty(arg.column()),</span>
<span class="fc bfc" id="L608" title="All 2 branches covered.">          arg.javaType() == void.class ? null : arg.javaType(),</span>
<span class="fc bfc" id="L609" title="All 2 branches covered.">          arg.jdbcType() == JdbcType.UNDEFINED ? null : arg.jdbcType(),</span>
<span class="fc" id="L610">          nullOrEmpty(arg.select()),</span>
<span class="fc" id="L611">          nullOrEmpty(arg.resultMap()),</span>
<span class="fc" id="L612">          null,</span>
<span class="fc" id="L613">          nullOrEmpty(arg.columnPrefix()),</span>
<span class="fc" id="L614">          typeHandler,</span>
<span class="fc" id="L615">          flags,</span>
<span class="fc" id="L616">          null,</span>
<span class="fc" id="L617">          null,</span>
<span class="fc" id="L618">          false);</span>
<span class="fc" id="L619">      resultMappings.add(resultMapping);</span>
    }
<span class="fc" id="L621">  }</span>

  private String nullOrEmpty(String value) {
<span class="pc bpc" id="L624" title="1 of 4 branches missed.">    return value == null || value.trim().length() == 0 ? null : value;</span>
  }

  private Result[] resultsIf(Results results) {
<span class="fc bfc" id="L628" title="All 2 branches covered.">    return results == null ? new Result[0] : results.value();</span>
  }

  private Arg[] argsIf(ConstructorArgs args) {
<span class="fc bfc" id="L632" title="All 2 branches covered.">    return args == null ? new Arg[0] : args.value();</span>
  }

  private KeyGenerator handleSelectKeyAnnotation(SelectKey selectKeyAnnotation, String baseStatementId, Class&lt;?&gt; parameterTypeClass, LanguageDriver languageDriver) {
<span class="fc" id="L636">    String id = baseStatementId + SelectKeyGenerator.SELECT_KEY_SUFFIX;</span>
<span class="fc" id="L637">    Class&lt;?&gt; resultTypeClass = selectKeyAnnotation.resultType();</span>
<span class="fc" id="L638">    StatementType statementType = selectKeyAnnotation.statementType();</span>
<span class="fc" id="L639">    String keyProperty = selectKeyAnnotation.keyProperty();</span>
<span class="fc" id="L640">    String keyColumn = selectKeyAnnotation.keyColumn();</span>
<span class="fc" id="L641">    boolean executeBefore = selectKeyAnnotation.before();</span>

    // defaults
<span class="fc" id="L644">    boolean useCache = false;</span>
<span class="fc" id="L645">    KeyGenerator keyGenerator = NoKeyGenerator.INSTANCE;</span>
<span class="fc" id="L646">    Integer fetchSize = null;</span>
<span class="fc" id="L647">    Integer timeout = null;</span>
<span class="fc" id="L648">    boolean flushCache = false;</span>
<span class="fc" id="L649">    String parameterMap = null;</span>
<span class="fc" id="L650">    String resultMap = null;</span>
<span class="fc" id="L651">    ResultSetType resultSetTypeEnum = null;</span>

<span class="fc" id="L653">    SqlSource sqlSource = buildSqlSourceFromStrings(selectKeyAnnotation.statement(), parameterTypeClass, languageDriver);</span>
<span class="fc" id="L654">    SqlCommandType sqlCommandType = SqlCommandType.SELECT;</span>

<span class="fc" id="L656">    assistant.addMappedStatement(id, sqlSource, statementType, sqlCommandType, fetchSize, timeout, parameterMap, parameterTypeClass, resultMap, resultTypeClass, resultSetTypeEnum,</span>
<span class="fc" id="L657">        flushCache, useCache, false,</span>
<span class="fc" id="L658">        keyGenerator, keyProperty, keyColumn, null, languageDriver, null);</span>

<span class="fc" id="L660">    id = assistant.applyCurrentNamespace(id, false);</span>

<span class="fc" id="L662">    MappedStatement keyStatement = configuration.getMappedStatement(id, false);</span>
<span class="fc" id="L663">    SelectKeyGenerator answer = new SelectKeyGenerator(keyStatement, executeBefore);</span>
<span class="fc" id="L664">    configuration.addKeyGenerator(id, answer);</span>
<span class="fc" id="L665">    return answer;</span>
  }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>